import fs from "fs/promises";
import { McapWriter } from "@mcap/core";
import { FileHandleWritable } from "@mcap/nodejs";
import { PointCloud, Point3 } from "@foxglove/schemas";
import { time, timeStamp } from "console";

// writeMcapA().catch(console.error);
// writeMcapB().catch(console.error);
// writeMcapC().catch(console.error);

// writeMcapPointCloud().catch(console.error);
writeMcapCameraModel().catch(console.error);

async function writeMcapA() {
  const outputStream = await fs.open("mcapA.mcap", "w");

  const writer = new McapWriter({
    writable: new FileHandleWritable(outputStream),
  });

  const schemaId = await writer.registerSchema({
    name: "schema.A",
    encoding: "jsonschema",
    data: new TextEncoder().encode(
      JSON.stringify({
        type: "object",
        properties: {
          i: { type: "integer" },
          id: { type: "integer" },
          name: { type: "string" },
        },
      })
    ),
  });

  const schemaIdLog = await writer.registerSchema({
    name: "foxglove.Log",
    encoding: "jsonschema",
    data: new TextEncoder().encode(
      JSON.stringify({
        title: "foxglove.Log",
        description: "A log message",
        $comment: "Generated by https://github.com/foxglove/foxglove-sdk",
        type: "object",
        properties: {
          timestamp: {
            type: "object",
            title: "time",
            properties: {
              sec: {
                type: "integer",
                minimum: 0,
              },
              nsec: {
                type: "integer",
                minimum: 0,
                maximum: 999999999,
              },
            },
            description: "Timestamp of log message",
          },
          level: {
            title: "foxglove.LogLevel",
            description: "Log level",
            oneOf: [
              {
                title: "UNKNOWN",
                const: 0,
              },
              {
                title: "DEBUG",
                const: 1,
              },
              {
                title: "INFO",
                const: 2,
              },
              {
                title: "WARNING",
                const: 3,
              },
              {
                title: "ERROR",
                const: 4,
              },
              {
                title: "FATAL",
                const: 5,
              },
            ],
          },
          message: {
            type: "string",
            description: "Log message",
          },
          id: { type: "integer" },
          name: {
            type: "string",
            description: "Process or node name",
          },
          file: {
            type: "string",
            description: "Filename",
          },
          line: {
            type: "integer",
            minimum: 0,
            description: "Line number in the file",
          },
        },
      })
    ),
  });

  const channelId = await writer.registerChannel({
    schemaId,
    messageEncoding: "json",
    topic: "/topic/A",
    metadata: new Map(),
  });

  const channelIdLog = await writer.registerChannel({
    schemaId: schemaIdLog,
    messageEncoding: "json",
    topic: "/log",
    metadata: new Map(),
  });

  await writer.start({ library: "json", profile: "mcap-a" });

  for (let i = 0; i < 100; i++) {
    console.log("message " + i);

    const messageData = new TextEncoder().encode(
      JSON.stringify({
        i,
        id: Math.floor(Math.random() * 100),
        // random name
        name: "MCAP A " + Math.random().toString(36).substring(7),
      })
    );

    //calculate logTime using the index i, to have 100ms of difference between each message
    const logTime = BigInt(Date.now() + i * 100000000);

    const messageLogData = new TextEncoder().encode(
      JSON.stringify({
        i,
        line: i,
        message: `[${i}] Log message test at ${logTime.toString()}`,
        level: 1,
        timestamp: { sec: 0, nsec: Number(logTime) },
        file: "test file",
      })
    );

    await writer.addMessage({
      channelId: channelId,
      data: messageData,
      sequence: i,
      logTime: logTime,
      publishTime: logTime,
    });

    await writer.addMessage({
      channelId: channelIdLog,
      data: messageLogData,
      sequence: i,
      logTime: logTime,
      publishTime: logTime,
    });
  }

  await writer.end();
  await outputStream.close();
  console.log(`Wrinting MCAP A complete.`);
}

async function writeMcapB() {
  const outputStream = await fs.open("mcapB.mcap", "w");

  const writer = new McapWriter({
    writable: new FileHandleWritable(outputStream),
  });

  const schemaIdA = await writer.registerSchema({
    name: "schema.A",
    encoding: "jsonschema",
    data: new TextEncoder().encode(
      JSON.stringify({
        type: "object",
        properties: {
          i: { type: "integer" },
          id: { type: "integer" },
          name: { type: "string" },
        },
      })
    ),
  });

  const schemaIdB = await writer.registerSchema({
    name: "schema.B",
    encoding: "jsonschema",
    data: new TextEncoder().encode(
      JSON.stringify({
        type: "object",
        properties: {
          i: { type: "integer" },
          x: { type: "integer" },
          y: { type: "integer" },
        },
      })
    ),
  });

  const channelIdA = await writer.registerChannel({
    schemaId: schemaIdA,
    messageEncoding: "json",
    topic: "/topic/A",
    metadata: new Map(),
  });

  const channelIdB = await writer.registerChannel({
    schemaId: schemaIdB,
    messageEncoding: "json",
    topic: "/topic/B",
    metadata: new Map(),
  });

  await writer.start({ library: "json", profile: "mcap-b" });

  for (let i = 50; i < 150; i++) {
    const messageDataA = new TextEncoder().encode(
      JSON.stringify({
        i,
        id: Math.floor(Math.random() * 100),
        // random name
        name: "MCAP B " + Math.random().toString(36).substring(7),
      })
    );

    const messageDataB = new TextEncoder().encode(
      JSON.stringify({
        i,
        x: Math.floor(Math.random() * 100),
        y: Math.floor(Math.random() * 100),
      })
    );

    //calculate logTime using the index i, to have 100ms of difference between each message
    const logTime = BigInt(Date.now() + i * 100000000);

    await writer.addMessage({
      channelId: channelIdA,
      data: messageDataA,
      sequence: 0,
      logTime: logTime,
      publishTime: logTime,
    });

    await writer.addMessage({
      channelId: channelIdB,
      data: messageDataB,
      sequence: 0,
      logTime: logTime,
      publishTime: logTime,
    });
  }

  await writer.end();
  await outputStream.close();
  console.log(`Wrinting MCAP B complete.`);
}

async function writeMcapC() {
  const outputStream = await fs.open("mcapC.mcap", "w");

  const writer = new McapWriter({
    writable: new FileHandleWritable(outputStream),
  });

  const schemaId = await writer.registerSchema({
    name: "schema.B", // <- same schema name in the same topic, but different properties
    encoding: "jsonschema",
    data: new TextEncoder().encode(
      JSON.stringify({
        type: "object",
        properties: {
          i: { type: "integer" },
          name: { type: "string" },
          surname: { type: "string" },
          age: { type: "integer" },
        },
      })
    ),
  });

  const channelId = await writer.registerChannel({
    schemaId,
    messageEncoding: "json",
    topic: "/topic/B",
    metadata: new Map(),
  });

  await writer.start({ library: "json", profile: "mcap-c" });

  for (let i = 0; i < 150; i++) {
    const messageData = new TextEncoder().encode(
      JSON.stringify({
        i,
        name: "MCAP C " + Math.random().toString(36).substring(7),
        surname: "MCAP C " + Math.random().toString(36).substring(7),
        age: Math.floor(Math.random() * 80) + 10,
      })
    );

    //calculate logTime using the index i, to have 100ms of difference between each message
    const logTime = BigInt(Date.now() + i * 100000000);

    await writer.addMessage({
      channelId: channelId,
      data: messageData,
      sequence: 0,
      logTime: logTime,
      publishTime: logTime,
    });
  }

  await writer.end();
  await outputStream.close();
  console.log(`Wrinting MCAP C complete.`);
}

async function loadSchema(schemaName: string) {
  const response = await fetch(
    `https://raw.githubusercontent.com/foxglove/foxglove-sdk/refs/heads/main/schemas/jsonschema/${schemaName}.json`
  );
  const schema = await response.json();
  return new TextEncoder().encode(JSON.stringify(schema));
}

async function writeMcapPointCloud() {
  const outputStream = await fs.open("mcap_converters.mcap", "w");

  const writer = new McapWriter({
    writable: new FileHandleWritable(outputStream),
  });

  const schemaIdPointCloud = await writer.registerSchema({
    name: "foxglove.PointCloud",
    encoding: "jsonschema",
    data: await loadSchema("PointCloud"),
  });

  const schemaIdPoint3 = await writer.registerSchema({
    name: "foxglove.Point3",
    encoding: "jsonschema",
    data: await loadSchema("Point3"),
  });

  // const channelIdPointCloud = await writer.registerChannel({
  //   schemaId: schemaIdPointCloud,
  //   messageEncoding: "json",
  //   topic: "/point_cloud",
  //   metadata: new Map(),
  // });

  // const channelIdPointCloudColored = await writer.registerChannel({
  //   schemaId: schemaIdPointCloud,
  //   messageEncoding: "json",
  //   topic: "/point_cloud/colored",
  //   metadata: new Map(),
  // });

  const channelIdPoint3 = await writer.registerChannel({
    schemaId: schemaIdPoint3,
    messageEncoding: "json",
    topic: "/point_3",
    metadata: new Map(),
  });
  const channelIdPoint3_2 = await writer.registerChannel({
    schemaId: schemaIdPoint3,
    messageEncoding: "json",
    topic: "/point_3/2",
    metadata: new Map(),
  });

  await writer.start({ library: "json", profile: "mcap-point-cloud" });

  for (let i = 0; i < 100; i++) {
    const x = Math.random() * 100;
    const y = Math.random() * 100;
    const z = Math.random() * 100;
    const r = 255;
    const g = 0;
    const b = 0;
    const a = 0.5;

    // POINTS PROCESS
    // Packing data for the point cloud without colors (12 bytes: 3 floats for x, y, z)
    let pointCloudData = new Uint8Array(12); // 3 floats (x, y, z)
    let offset = 0;
    new DataView(pointCloudData.buffer).setFloat32(offset, x, true); // x
    offset += 4;
    new DataView(pointCloudData.buffer).setFloat32(offset, y, true); // y
    offset += 4;
    new DataView(pointCloudData.buffer).setFloat32(offset, z, true); // z

    // Packing data for the point cloud with colors (16 bytes: 3 floats for x, y, z + 4 bytes for RGBA)
    let pointColoredData = new Uint8Array(16); // 3 floats (x, y, z) + 4 bytes for RGBA
    offset = 0;
    new DataView(pointColoredData.buffer).setFloat32(offset, x, true); // x
    offset += 4;
    new DataView(pointColoredData.buffer).setFloat32(offset, y, true); // y
    offset += 4;
    new DataView(pointColoredData.buffer).setFloat32(offset, z, true); // z
    offset += 4;
    pointColoredData[offset] = r; // red
    pointColoredData[offset + 1] = g; // green
    pointColoredData[offset + 2] = b; // blue
    pointColoredData[offset + 3] = a * 255; // alpha (fully opaque)

    // Encode point cloud data (12 bytes) to base64
    const base64PointCloudData = btoa(
      String.fromCharCode.apply(null, pointCloudData)
    );

    // Encode point colored data (16 bytes) to base64
    const base64PointColoredData = btoa(
      String.fromCharCode.apply(null, pointColoredData)
    );

    const messageDataPointCloud = new TextEncoder().encode(
      JSON.stringify({
        timestamp: { sec: Math.floor(Date.now() / 1000), nsec: 0 },
        frame_id: "cloud",
        pose: {
          position: { x: 0, y: 0, z: 0 },
          orientation: { x: 0, y: 0, z: 0, w: 1 },
        },
        point_stride: 12, // 3 floats for x, y, z
        fields: [
          { name: "x", offset: 0, type: 7 },
          { name: "y", offset: 4, type: 7 },
          { name: "z", offset: 8, type: 7 },
        ],
        data: base64PointCloudData, // You can pack data here in base64 as needed
      })
    );

    const messageDataPointColored = new TextEncoder().encode(
      JSON.stringify({
        timestamp: { sec: Math.floor(Date.now() / 1000), nsec: 0 },
        frame_id: "cloud",
        pose: {
          position: { x: 0, y: 0, z: 0 },
          orientation: { x: 0, y: 0, z: 0, w: 1 },
        },
        point_stride: 16, // 3 floats for x, y, z + 4 bytes for each color (RGBA)
        fields: [
          { name: "x", offset: 0, type: 7 },
          { name: "y", offset: 4, type: 7 },
          { name: "z", offset: 8, type: 7 },
          { name: "red", offset: 12, type: 1 },
          { name: "green", offset: 13, type: 1 },
          { name: "blue", offset: 14, type: 1 },
          { name: "alpha", offset: 15, type: 1 },
        ],
        data: base64PointColoredData, // You can pack data here in base64 as needed
      })
    );

    const messageDataPoint3 = new TextEncoder().encode(
      JSON.stringify({
        x,
        y,
        z,
      })
    );

    //calculate logTime using the index i, to have 100ms of difference between each message
    const logTime = BigInt(Date.now() + i * 100000000);

    // await writer.addMessage({
    //   channelId: channelIdPointCloud,
    //   data: messageDataPointCloud,
    //   sequence: 0,
    //   logTime: logTime,
    //   publishTime: logTime,
    // });

    // await writer.addMessage({
    //   channelId: channelIdPointCloudColored,
    //   data: messageDataPointColored,
    //   sequence: 0,
    //   logTime: logTime,
    //   publishTime: logTime,
    // });

    await writer.addMessage({
      channelId: channelIdPoint3,
      data: messageDataPoint3,
      sequence: 0,
      logTime: logTime,
      publishTime: logTime + 100000000n,
    });
    await writer.addMessage({
      channelId: channelIdPoint3_2,
      data: messageDataPoint3,
      sequence: 0,
      logTime: logTime,
      publishTime: logTime + 100000000n,
    });
  }

  await writer.end();
  await outputStream.close();
  console.log(`Wrinting MCAP Point Cloud complete.`);
}

async function writeMcapCameraModel() {
  const outputStream = await fs.open("custom-camera-models.mcap", "w");

  const writer = new McapWriter({
    writable: new FileHandleWritable(outputStream),
  });

  const schemaIdCompressedImage = await writer.registerSchema({
    name: "foxglove.CompressedImage",
    encoding: "jsonschema",
    data: await loadSchema("CompressedImage"),
  });

  const schemaIdCameraCalibration = await writer.registerSchema({
    name: "foxglove.CameraCalibration",
    encoding: "jsonschema",
    data: await loadSchema("CameraCalibration"),
  });

  const channelIdCompressedImage = await writer.registerChannel({
    schemaId: schemaIdCompressedImage,
    messageEncoding: "json",
    topic: "/image/compressed",
    metadata: new Map(),
  });
  const channelIdCameraCalibration = await writer.registerChannel({
    schemaId: schemaIdCameraCalibration,
    messageEncoding: "json",
    topic: "/camera_calibration",
    metadata: new Map(),
  });
  const channelIdCameraCalibrationCustom = await writer.registerChannel({
    schemaId: schemaIdCameraCalibration,
    messageEncoding: "json",
    topic: "/camera_calibration/custom",
    metadata: new Map(),
  });

  await writer.start({ library: "json", profile: "custom-camera-models" });

  // Create a JPEG image from a path:
  const jpegData = await fs.readFile("./test.jpg");
  const jpegDataArray = new Uint8Array(jpegData);

  for (let i = 0; i < 10; i++) {
    const messageCompressedImage = new TextEncoder().encode(
      JSON.stringify({
        timestamp: { sec: Math.floor(Date.now() / 1000), nsec: 0 },
        frame_id: "camera",
        data: btoa(String.fromCharCode(...jpegDataArray)), // fake jpeg data
        format: "jpeg",
      })
    );

    const commonCameraCalibration = {
      timestamp: { sec: Math.floor(Date.now() / 1000), nsec: 0 },
      frame_id: "camera",
      width: 640,
      height: 480,
      distortion_model: "plumb_bob",
      D: [
        -0.2, 0.1, 0.0, 0.0, 0.0,
        // distortion coefficients
      ],
      K: [
        800, 0, 320, 0, 800, 240, 0, 0, 1,
        // intrinsic camera matrix (3x3 row-major matrix)
      ],
      R: [
        1, 0, 0, 0, 1, 0, 0, 0, 1,
        // rectification matrix (stereo cameras only, 3x3 row-major matrix)
      ],
      P: [
        800, 0, 320, 0, 0, 800, 240, 0, 0, 0, 1, 0,
        // projection matrix (3x4 row-major matrix)
      ],
    };

    const messageCameraCalibration = new TextEncoder().encode(
      JSON.stringify(commonCameraCalibration)
    );

    const messageCameraCalibrationCustom = new TextEncoder().encode(
      JSON.stringify({
        ...commonCameraCalibration,
        distortion_model: "CylinderCameraModel",
      })
    );

    const logTime = BigInt(Date.now() + i * 100000000);

    await writer.addMessage({
      channelId: channelIdCompressedImage,
      data: messageCompressedImage,
      sequence: 0,
      logTime: logTime,
      publishTime: logTime + 100000000n,
    });
    await writer.addMessage({
      channelId: channelIdCameraCalibration,
      data: messageCameraCalibration,
      sequence: 0,
      logTime: logTime,
      publishTime: logTime + 100000000n,
    });
    await writer.addMessage({
      channelId: channelIdCameraCalibrationCustom,
      data: messageCameraCalibrationCustom,
      sequence: 0,
      logTime: logTime,
      publishTime: logTime + 100000000n,
    });
  }

  await writer.end();
  await outputStream.close();
  console.log(`Wrinting MCAP Point Cloud complete.`);
}
